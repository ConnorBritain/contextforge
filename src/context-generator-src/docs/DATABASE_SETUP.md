# Database Setup Guide for ContextForge (Firebase Firestore)

This guide explains how to set up and configure the Firebase Firestore database used in ContextForge.

## Database Architecture

ContextForge uses **Firebase Firestore** as its primary database for:

*   Storing user authentication information (managed by Firebase Authentication).
*   Persisting multi-step wizard form data (**`wizardResponses`** collection).
*   Storing the status and results of AI document generation (updated within the corresponding **`wizardResponses`** document by a Cloud Function).

MongoDB is **no longer used** in this project.

## Firestore Setup

These steps are performed in the [Firebase Console](https://console.firebase.google.com/) for your project.

1.  **Select Your Project:** Ensure you have the correct Firebase project selected.
2.  **Navigate to Firestore:** Go to **Build > Firestore Database** in the left-hand menu.
3.  **Create Database:**
    *   If you haven't already, click **Create database**.
    *   Choose **Start in production mode** (recommended) or **test mode**.
        *   *Production mode* starts with secure rules (deny all access). You will deploy the project's `firestore.rules` to grant specific access.
        *   *Test mode* starts with open rules (allow all reads/writes for 30 days). Useful for initial development but **must be secured before launch**.
    *   Select a Firestore location (e.g., `us-central`, `europe-west`). **This cannot be changed later.**
    *   Click **Enable**.

4.  ** Firestore is now enabled!** The application code (backend server and Cloud Functions) will interact with this database using the Firebase Admin SDK, and the client will use Firestore listeners (`onSnapshot`) to get real-time updates.

## Security Rules (`firestore.rules`)

The project includes a `firestore.rules` file defining the access control logic for your database. It's crucial to deploy these rules:

*   The current rules primarily secure the **`wizardResponses`** collection.
*   They ensure that users can only read/write documents where the `userId` field within the document matches their authenticated UID.
*   To deploy the rules from your local environment (ensure Firebase CLI is installed and logged in):
    ```bash
    # Run from the root project directory
    firebase deploy --only firestore:rules
    ```
*   Regularly review and update these rules as your data structure or access requirements change.

## Data Model (`wizardResponses` Collection)

Each document in the `wizardResponses` collection represents a saved wizard draft and its potential generation result.

*   **Document ID:** `{userId}_{wizardId}` (e.g., `qR7p..._wizard-1678886400000`)
*   **Fields:**
    *   `userId`: (String) The Firebase Auth UID of the user who owns the draft.
    *   `id`: (String) The original wizard session ID (e.g., `wizard-1678886400000`).
    *   `documentType`: (String) The type of document being generated (e.g., `personalBio`).
    *   `createdAt`: (Timestamp) When the draft was first saved.
    *   `updatedAt`: (Timestamp) When the draft was last saved.
    *   `title`: (String, Optional) User-defined title for the draft.
    *   `...otherFormData`: All the fields collected from the specific wizard form.
    *   **`generationStatus`**: (String, Optional) Set by the Cloud Function:
        *   `processing`: Generation is in progress.
        *   `complete`: Generation finished successfully.
        *   `complete_with_errors`: Generation finished, but some chunk errors occurred.
        *   `error`: Generation failed due to an unrecoverable error.
    *   **`generatedDocument`**: (Object, Optional) The final structured document generated by the AI (set when `generationStatus` is `complete` or `complete_with_errors`).
    *   **`processingStartedAt`**: (Timestamp, Optional) When the Cloud Function started processing.
    *   **`processingCompletedAt`**: (Timestamp, Optional) When the Cloud Function finished processing.
    *   **`chunkCount`**: (Number, Optional) Number of chunks the input was split into.
    *   **`chunk_X_status`**: (String, Optional) Status for individual chunks (`processing`, `complete`, `error`).
    *   **`error`**: (String, Optional) Error message if `generationStatus` is `error`.
    *   **`chunkErrors`**: (Array, Optional) List of errors encountered during chunk processing if `generationStatus` is `complete_with_errors`.

## Local Development with Emulators

For local development without connecting to your live Firestore instance, you can use the [Firebase Emulator Suite](https://firebase.google.com/docs/emulator-suite).

1.  **Install Emulators:** `firebase setup:emulators:firestore` (follow prompts).
2.  **Start Emulators:** `firebase emulators:start --only firestore,auth` (add other emulators like functions if needed).
3.  **Configure App:** Your application code (client/server/functions) needs to be configured to connect to the emulators when they are running. This often involves checking environment variables (like `FIRESTORE_EMULATOR_HOST`) or using conditional logic during Firebase SDK initialization.

Refer to the [Firebase Emulator documentation](https://firebase.google.com/docs/emulator-suite/connect_firestore) for details on connecting your app.

## References

*   [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)
*   [Understanding Firestore Security Rules](https://firebase.google.com/docs/firestore/security/overview)
*   [Firebase Emulator Suite](https://firebase.google.com/docs/emulator-suite)
